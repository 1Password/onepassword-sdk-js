/*
 Generated by typeshare 1.13.2
*/

export type ErrorMessage = string;

/** Additional attributes for OTP fields. */
export interface AddressFieldDetails {
  /** The street address */
  street: string;
  /** The city */
  city: string;
  /** The country */
  country: string;
  /** The ZIP code */
  zip: string;
  /** The state */
  state: string;
}

export interface DocumentCreateParams {
  /** The name of the file */
  name: string;
  /** The content of the file */
  content: Uint8Array;
}

export interface FileAttributes {
  /** The name of the file */
  name: string;
  /** The ID of the file retrieved from the server */
  id: string;
  /** The size of the file in bytes */
  size: number;
}

export interface FileCreateParams {
  /** The name of the file */
  name: string;
  /** The content of the file */
  content: Uint8Array;
  /** The section id where the file should be stored */
  sectionId: string;
  /** The field id where the file should be stored */
  fieldId: string;
}

/**
 * For future use, if we want to return more information about the generated password.
 * Currently, it only returns the password itself.
 */
export interface GeneratePasswordResponse {
  /** The generated password. */
  password: string;
}

/**
 * Represents a group's access to a 1Password vault.
 * This is used for granting permissions
 */
export interface GroupAccess {
  /** The group's ID */
  group_id: string;
  /** The group's set of permissions for the vault */
  permissions: number;
}

/** Represents a group's access to a 1Password vault. */
export interface GroupVaultAccess {
  /** The vault's ID */
  vault_id: string;
  /** The group's ID */
  group_id: string;
  /** The group's set of permissions for the vault */
  permissions: number;
}

export enum ItemCategory {
  Login = "Login",
  SecureNote = "SecureNote",
  CreditCard = "CreditCard",
  CryptoWallet = "CryptoWallet",
  Identity = "Identity",
  Password = "Password",
  Document = "Document",
  ApiCredentials = "ApiCredentials",
  BankAccount = "BankAccount",
  Database = "Database",
  DriverLicense = "DriverLicense",
  Email = "Email",
  MedicalRecord = "MedicalRecord",
  Membership = "Membership",
  OutdoorLicense = "OutdoorLicense",
  Passport = "Passport",
  Rewards = "Rewards",
  Router = "Router",
  Server = "Server",
  SshKey = "SshKey",
  SocialSecurityNumber = "SocialSecurityNumber",
  SoftwareLicense = "SoftwareLicense",
  Person = "Person",
  Unsupported = "Unsupported",
}

export enum ItemFieldType {
  Text = "Text",
  Concealed = "Concealed",
  CreditCardType = "CreditCardType",
  CreditCardNumber = "CreditCardNumber",
  Phone = "Phone",
  Url = "Url",
  Totp = "Totp",
  Email = "Email",
  Reference = "Reference",
  SshKey = "SshKey",
  Menu = "Menu",
  MonthYear = "MonthYear",
  Address = "Address",
  Date = "Date",
  Unsupported = "Unsupported",
}

/** Field type-specific attributes. */
export type ItemFieldDetails =
  /** The computed OTP code and other details */
  | { type: "Otp"; content: OtpFieldDetails }
  /** Computed SSH Key attributes */
  | { type: "SshKey"; content?: SshKeyAttributes }
  /** Address components */
  | { type: "Address"; content?: AddressFieldDetails };

/** Represents a field within an item. */
export interface ItemField {
  /** The field's ID */
  id: string;
  /** The field's title */
  title: string;
  /** The ID of the section containing the field. Built-in fields such as usernames and passwords don't require a section. */
  sectionId?: string;
  /** The field's type */
  fieldType: ItemFieldType;
  /** The string representation of the field's value */
  value: string;
  /** Field type-specific attributes. */
  details?: ItemFieldDetails;
}

/** A section groups together multiple fields in an item. */
export interface ItemSection {
  /** The section's unique ID */
  id: string;
  /** The section's title */
  title: string;
}

/**
 * Controls the auto-fill behavior of a website.
 *
 *
 * For more information, visit https://support.1password.com/autofill-behavior/
 */
export enum AutofillBehavior {
  /** Auto-fill any page thatâ€™s part of the website, including subdomains */
  AnywhereOnWebsite = "AnywhereOnWebsite",
  /** Auto-fill only if the domain (hostname and port) is an exact match. */
  ExactDomain = "ExactDomain",
  /** Never auto-fill on this website */
  Never = "Never",
}

export interface Website {
  /** The website URL */
  url: string;
  /** The label of the website, e.g. 'website', 'sign-in address' */
  label: string;
  /**
   * The auto-fill behavior of the website
   *
   * For more information, visit https://support.1password.com/autofill-behavior/
   */
  autofillBehavior: AutofillBehavior;
}

export interface ItemFile {
  /** the attributes of the file */
  attributes: FileAttributes;
  /** the section id where the file should be stored */
  sectionId: string;
  /** the field id where the file should be stored */
  fieldId: string;
}

/** Represents an active 1Password item. */
export interface Item {
  /** The item's ID */
  id: string;
  /** The item's title */
  title: string;
  /** The item's category */
  category: ItemCategory;
  /** The ID of the vault where the item is saved */
  vaultId: string;
  /** The item's fields */
  fields: ItemField[];
  /** The item's sections */
  sections: ItemSection[];
  /** The notes of the item */
  notes: string;
  /** The item's tags */
  tags: string[];
  /** The websites used for autofilling for items of the Login and Password categories. */
  websites: Website[];
  /** The item's version */
  version: number;
  /** The item's file fields */
  files: ItemFile[];
  /** The document file for the Document item category */
  document?: FileAttributes;
  /** The time the item was created at */
  createdAt: Date;
  /** The time the item was updated at */
  updatedAt: Date;
}

export interface ItemCreateParams {
  /** The item's category */
  category: ItemCategory;
  /** The ID of the vault where the item is saved */
  vaultId: string;
  /** The item's title */
  title: string;
  /** The item's fields */
  fields?: ItemField[];
  /** The item's sections */
  sections?: ItemSection[];
  /** The item's notes */
  notes?: string;
  /** The item's tags */
  tags?: string[];
  /** The websites used for autofilling for items of the Login and Password categories. */
  websites?: Website[];
  /** The item's files stored as fields */
  files?: FileCreateParams[];
  /** The document file for the Document item type. Empty when the item isn't of Document type. */
  document?: DocumentCreateParams;
}

/** Represents the state of an item in the SDK. */
export enum ItemState {
  /** The item is active */
  Active = "active",
  /** The item is archived meaning it's hidden from regular view and stored in the archive. */
  Archived = "archived",
}

/** Represents a decrypted 1Password item overview. */
export interface ItemOverview {
  /** The item's ID */
  id: string;
  /** The item's title */
  title: string;
  /** The item's category */
  category: ItemCategory;
  /** The ID of the vault where the item is saved */
  vaultId: string;
  /** The websites used for autofilling for items of the Login and Password categories. */
  websites: Website[];
  /** The item tags */
  tags: string[];
  /** The time the item was created at */
  createdAt: Date;
  /** The time the item was updated at */
  updatedAt: Date;
  /** Indicates the state of the item */
  state: ItemState;
}

/** The valid duration options for sharing an item */
export enum ItemShareDuration {
  /** The share will expire in one hour */
  OneHour = "OneHour",
  /** The share will expire in one day */
  OneDay = "OneDay",
  /** The share will expire in seven days */
  SevenDays = "SevenDays",
  /** The share will expire in fourteen days */
  FourteenDays = "FourteenDays",
  /** The share will expire in thirty days */
  ThirtyDays = "ThirtyDays",
}

/** The allowed types of item sharing, enforced by account policy */
export enum AllowedType {
  /** Allows creating share links with specific recipients */
  Authenticated = "Authenticated",
  /** Allows creating public share links */
  Public = "Public",
}

/** The allowed recipient types of item sharing, enforced by account policy */
export enum AllowedRecipientType {
  /** Recipients can be specified by email address */
  Email = "Email",
  /** Recipients can be specified by domain */
  Domain = "Domain",
}

/** The file sharing policy */
export interface ItemShareFiles {
  /** Whether files can be included in item shares */
  allowed: boolean;
  /** The maximum encrypted size (in bytes) an included file can be */
  maxSize: number;
  /** The allowed types of item sharing - either "Authenticated" (share to specific users) or "Public" (share to anyone with a link) */
  allowedTypes?: AllowedType[];
  /** The allowed recipient types of item sharing - either "Email" or "Domain" */
  allowedRecipientTypes?: AllowedRecipientType[];
  /** The maximum duration that an item can be shared for */
  maxExpiry?: ItemShareDuration;
  /** The default duration that an item is shared for */
  defaultExpiry?: ItemShareDuration;
  /** The maximum number of times an item can be viewed. A null value means unlimited views */
  maxViews?: number;
}

/**
 * The account policy for sharing items, set by your account owner/admin
 * This policy is enforced server-side when sharing items
 */
export interface ItemShareAccountPolicy {
  /** The maximum duration that an item can be shared for */
  maxExpiry: ItemShareDuration;
  /** The default duration that an item is shared for */
  defaultExpiry: ItemShareDuration;
  /** The maximum number of times an item can be viewed. A null value means unlimited views */
  maxViews?: number;
  /** The allowed types of item sharing - either "Authenticated" (share to specific users) or "Public" (share to anyone with a link) */
  allowedTypes: AllowedType[];
  /** The allowed recipient types of item sharing - either "Email" or "Domain" */
  allowedRecipientTypes: AllowedRecipientType[];
  /** The file sharing policy */
  files: ItemShareFiles;
}

/** The validated recipient of an item share */
export type ValidRecipient =
  /** This exact email address */
  | {
      type: "Email";
      parameters: {
        email: string;
      };
    }
  /** Anyone with an email address from the specified domain */
  | {
      type: "Domain";
      parameters: {
        domain: string;
      };
    };

/**
 * The configuration options for sharing an item
 * These must respect the account policy on item sharing
 */
export interface ItemShareParams {
  /** Emails or domains of the item share recipients. If not provided, everyone with the share link will have access */
  recipients?: ValidRecipient[];
  /** The duration of the share in seconds. If not provided, defaults to the account policy's default expiry */
  expireAfter?: ItemShareDuration;
  /** Whether the item can only be viewed once per recipient */
  oneTimeOnly: boolean;
}

export interface Response<T, E> {
  content?: T;
  error?: E;
}

export type ItemUpdateFailureReason =
  /** Item update operation failed due to bad user input. */
  | { type: "itemValidationError"; message: ErrorMessage }
  /** Item update operation is forbidden, permission issue. Make sure you have the correct permissions to update items in this vault. */
  | { type: "itemStatusPermissionError"; message?: undefined }
  /** Item update operation failed due to incorrect version. */
  | { type: "itemStatusIncorrectItemVersion"; message?: undefined }
  /** Item update operation failed because a file reference didn't match a known file. */
  | { type: "itemStatusFileNotFound"; message?: undefined }
  /** Item update request is too big to be sent to the server. */
  | { type: "itemStatusTooBig"; message?: undefined }
  /** The item was not found */
  | { type: "itemNotFound"; message?: undefined }
  /** Item update operation experienced an internal error. */
  | { type: "internal"; message: ErrorMessage };

export interface ItemsDeleteAllResponse {
  individualResponses: Record<
    string,
    Response<undefined, ItemUpdateFailureReason>
  >;
}

export type ItemsGetAllError =
  | { type: "itemNotFound"; message?: undefined }
  | { type: "internal"; message: ErrorMessage };

export interface ItemsGetAllResponse {
  individualResponses: Response<Item, ItemsGetAllError>[];
}

export interface ItemsUpdateAllResponse {
  individualResponses: Response<Item, ItemUpdateFailureReason>[];
}

/** Additional attributes for OTP fields. */
export interface OtpFieldDetails {
  /** The OTP code, if successfully computed */
  code?: string;
  /** The error message, if the OTP code could not be computed */
  errorMessage?: string;
}

export interface ResolvedReference {
  secret: string;
  itemId: string;
  vaultId: string;
}

export type ResolveReferenceError =
  /** Error parsing the secret reference */
  | { type: "parsing"; message: ErrorMessage }
  /** The specified reference cannot be found within the item */
  | { type: "fieldNotFound"; message?: undefined }
  /** No vault matched the secret reference query */
  | { type: "vaultNotFound"; message?: undefined }
  /** More than one vault matched the secret reference query */
  | { type: "tooManyVaults"; message?: undefined }
  /** No item matched the secret reference query */
  | { type: "itemNotFound"; message?: undefined }
  /** More than one item matched the secret reference query */
  | { type: "tooManyItems"; message?: undefined }
  /** More than one field matched the provided secret reference */
  | { type: "tooManyMatchingFields"; message?: undefined }
  /** No section found within the item for the provided identifier */
  | { type: "noMatchingSections"; message?: undefined }
  /** Incompatiable TOTP query parameters */
  | { type: "incompatibleTOTPQueryParameterField"; message?: undefined }
  /** The totp was not able to be generated */
  | { type: "unableToGenerateTotpCode"; message: ErrorMessage }
  /** Couldn't find attributes specific to an SSH Key field */
  | { type: "sSHKeyMetadataNotFound"; message?: undefined }
  /** Currently only support text files */
  | { type: "unsupportedFileFormat"; message?: undefined }
  /** Trying to convert a non-private key to a private key format */
  | { type: "incompatibleSshKeyQueryParameterField"; message?: undefined }
  /** Unable to properly parse a private key string to convert to an internal Private Key type */
  | { type: "unableToParsePrivateKey"; message?: undefined }
  /** Unable to format a private key to OpenSSH format */
  | { type: "unableToFormatPrivateKeyToOpenSsh"; message?: undefined }
  /** Other type */
  | { type: "other"; message?: undefined };

export interface ResolveAllResponse {
  individualResponses: Record<
    string,
    Response<ResolvedReference, ResolveReferenceError>
  >;
}

export interface SshKeyAttributes {
  /** The public part of the SSH Key */
  publicKey: string;
  /** The fingerprint of the SSH Key */
  fingerprint: string;
  /** The key type ("Ed25519" or "RSA, {length}-bit") */
  keyType: string;
}

/** Represents the vault type. */
export enum VaultType {
  Personal = "personal",
  Everyone = "everyone",
  Transfer = "transfer",
  UserCreated = "userCreated",
  Unsupported = "unsupported",
}

export enum VaultAccessorType {
  User = "user",
  Group = "group",
}

/** Represents the vault access information. */
export interface VaultAccess {
  /** The vault's UUID. */
  vaultUuid: string;
  /** The vault's accessor type. */
  accessorType: VaultAccessorType;
  /** The vault's accessor UUID. */
  accessorUuid: string;
  /** The permissions granted to this vault */
  permissions: number;
}

/** Represents regular vault information together with the vault's access information. */
export interface Vault {
  /** The vault's ID. */
  id: string;
  /** The vault's title. */
  title: string;
  /** The description of the vault. */
  description: string;
  /** The type of the vault. */
  vaultType: VaultType;
  /** The number of active items within the vault. */
  activeItemCount: number;
  /** The content version number of the vault. It gets incremented whenever the state of the vault's contents changes (e.g. items from within the vault get created or updated). */
  contentVersion: number;
  /** The attribute version number of the vault. It gets incremented whenever vault presentation information changes, such as its title or icon. */
  attributeVersion: number;
  /** The access information associated with the vault. */
  access?: VaultAccess[];
}

/** Represents the possible query parameters used for retrieving extra information about a vault. */
export interface VaultGetParams {
  /** The vault's accessor params. */
  accessors?: boolean;
}

export interface VaultListParams {
  decryptDetails?: boolean;
}

/** Holds information about a 1Password Vault. */
export interface VaultOverview {
  /** The vault's ID. */
  id: string;
  /** The vault's title. */
  title: string;
  /** The description of this vault. */
  description: string;
  /** The type of the vault. */
  vaultType: VaultType;
  /** The number of active items within the vault. */
  activeItemCount: number;
  /** The content version number of the vault. It gets incremented whenever the state of the vault's contents changes (e.g. items from within the vault get created or updated). */
  contentVersion: number;
  /** The attribute version number of the vault. It gets incremented whenever vault presentation information changes, such as its title or icon. */
  attributeVersion: number;
  /** The time the vault was created at */
  createdAt: Date;
  /** The time the vault was updated at */
  updatedAt: Date;
}

export type ItemListFilter = {
  type: "ByState";
  content: {
    active: boolean;
    archived: boolean;
  };
};

export type PasswordRecipe =
  | {
      type: "Memorable";
      parameters: {
        /** The type of separator between chunks. */
        separatorType: SeparatorType;
        /** Uppercase one randomly selected chunk. */
        capitalize: boolean;
        /** The type of word list used. */
        wordListType: WordListType;
        /** The number of "words" (words or syllables). */
        wordCount: number;
      };
    }
  | {
      type: "Pin";
      parameters: {
        /** Number of digits in the PIN. */
        length: number;
      };
    }
  | {
      type: "Random";
      parameters: {
        /** Include at least one digit in the password. */
        includeDigits: boolean;
        /** Include at least one symbol in the password. */
        includeSymbols: boolean;
        /** The length of the password. */
        length: number;
      };
    };

export enum SeparatorType {
  /**
   * Randomly selected digits.
   * E.g, "`correct4horse0battery1staple`"
   */
  Digits = "digits",
  /**
   * Randomly selected digits and symbols.
   * This is useful to get word-based passwords to meet complexity requirements
   * E.g, "`correct4horse-battery1staple`"
   */
  DigitsAndSymbols = "digitsAndSymbols",
  /**
   * Spaces, like the original Diceware.
   * Great for mobile keyboards, not so great when people can overhear you type the password.
   * E.g, "`correct horse battery staple`"
   */
  Spaces = "spaces",
  /**
   * Hyphens "`-`".
   * E.g, "`correct-horse-battery-staple`"
   */
  Hyphens = "hyphens",
  /**
   * "`_`".
   * E.g, "`correct_horse_battery_staple`"
   */
  Underscores = "underscores",
  /**
   * Period (full stop) "`.`".
   * E.g, "`correct.horse.battery.staple`"
   */
  Periods = "periods",
  /**
   * Comma "`,`".
   * E.g, "`correct,horse,battery,staple`"
   */
  Commas = "commas",
}

export enum WordListType {
  /** Agile wordlist */
  FullWords = "fullWords",
  /** English-like syllables */
  Syllables = "syllables",
  /** Three (random) letter "words" */
  ThreeLetters = "threeLetters",
}

/**
 * Custom JSON reviver and replacer functions for dynamic data transformation
 * ReviverFunc is used during JSON parsing to detect and transform specific data structures
 * ReplacerFunc is used during JSON serialization to modify certain values before stringifying.
 * These functions allow for flexible encoding and decoding of data, ensuring that complex types are properly handled when converting between TS objects and JSON
 */
export const ReviverFunc = (key: string, value: unknown): unknown => {
  if (
    typeof value === "string" &&
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/.test(value) &&
    (key === "createdAt" || key === "updatedAt")
  ) {
    return new Date(value);
  }
  if (
    Array.isArray(value) &&
    value.every((v) => Number.isInteger(v) && v >= 0 && v <= 255) &&
    value.length > 0
  ) {
    return new Uint8Array(value);
  }
  return value;
};

export const ReplacerFunc = (key: string, value: unknown): unknown => {
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (value instanceof Uint8Array) {
    return Array.from(value);
  }
  return value;
};
